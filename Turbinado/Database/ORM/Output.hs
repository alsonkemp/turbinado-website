module Turbinado.Database.ORM.Output where

import qualified Data.Char
import Control.Monad
import Data.Dynamic
import qualified Data.Map as M
import Data.Maybe
import Data.List
import Database.HDBC
import System.Directory
import System.FilePath

import Turbinado.Database.ORM.Types

type TypeName = String

-- TODO: This file needs to be completely torn up and generalized.

writeModels ts = 
  do writeFile "App/Models/Bases/ModelBase.hs" generateModelBase
     mapM_ (\(t, (cs, pk)) -> 
                 let typeName = (capitalizeName t)
                     fullName = typeName ++ "Model" in
                 do e <- doesFileExist (joinPath ["App/Models", fullName ++ ".hs"])
                    when (not e) (writeFile (joinPath ["App/Models", fullName++".hs"]) (generateModelFile typeName) ) 
                    writeFile (joinPath ["App/Models/Bases", fullName ++ "Base.hs"]) (generateModel t typeName pk cs)
           ) $ M.toList ts

---------------------------------------------------------------------------
--  File templates                                                       --
---------------------------------------------------------------------------

generateModel ::  TableName ->
                  TypeName ->
                  PrimaryKey -> 
                  Columns -> 
                  String
generateModel t typeName pk cs = 
  unlines $
  ["{- DO NOT EDIT THIS FILE"
  ,"   THIS FILE IS AUTOMAGICALLY GENERATED AND YOUR CHANGES WILL BE EATEN BY THE GENERATOR OVERLORD"
  ,""
  ,"   All changes should go into the Model file (e.g. App/Models/ExampleModel.hs) and"
  ,"   not into the base file (e.g. App/Models/Bases/ExampleModelBase.hs) -}"
  ,""
  ,"module App.Models.Bases." ++ typeName ++ "ModelBase ( "
  ," module App.Models.Bases." ++ typeName ++ "ModelBase, "
  ," module App.Models.Bases.ModelBase) where"
  , ""
  , "import App.Models.Bases.ModelBase"
  , "import qualified Database.HDBC as HDBC"
  , "import Data.Maybe"
  , "import System.Time"
  , ""
  , "import Turbinado.Environment.Types"
  , "import Turbinado.Environment.Database"
  , ""
  , "data " ++ typeName ++ " = " ++ typeName ++ " {"
  ] ++
  [intercalate "," (map columnToFieldLabel (M.toList cs))] ++
  [ "    } deriving (Eq, Show)"
  , ""
  , "instance DatabaseModel " ++ typeName ++ " where"
  , "    tableName _ = \"" ++ t ++ "\""
  , ""
  ] ++
  generateIsModel t cs typeName ++
  generateHasFindByPrimaryKey t cs typeName pk
 
generateModelFile typeName =
  unlines $
  ["module App.Models." ++ typeName ++ "Model"
  ,"  ( module App.Models." ++ typeName ++ "Model"
  ,"  , module App.Models.Bases." ++ typeName ++ "ModelBase"
  ,"  ) where"
  ,"import App.Models.Bases." ++ typeName ++ "ModelBase"
  ]

generateModelBase :: String
generateModelBase = unlines $
  ["{- DO NOT EDIT THIS FILE"
  ,"   THIS FILE IS AUTOMAGICALLY GENERATED AND YOUR CHANGES WILL BE EATEN BY THE GENERATOR OVERLORD -}"
  ,""
  ,"module App.Models.Bases.ModelBase ("
  ,"  module App.Models.Bases.ModelBase,"
  ,"  module Control.Exception,"
  ,"  module Control.Monad.Trans,"
  ,"  module Data.Int"
  ,"  ) where"
  ,""
  ,"import Control.Monad.Trans"
  ,"import Control.Exception"
  ,"import Database.HDBC"
  ,"import Data.Int"
  ,""
  ,"import Turbinado.Environment.Types"
  ,""
  ,"-- Using phantom types here "
  ,"class DatabaseModel m where"
  ,"  tableName :: m -> String"
  ,""
  ,"type SelectString = String"
  ,"type SelectParams = [SqlValue]"
  ,"type OrderByParams  = String"
  ,""
  ,"class (DatabaseModel model) =>"
  ,"        IsModel model where"
  ,"        insert    :: (HasEnvironment m) => model -> Bool -> m (Maybe Integer)"
  ,"        findAll   :: (HasEnvironment m) => m [model]"
  ,"        findAllWhere :: (HasEnvironment m) => SelectString -> SelectParams -> m [model]"
  ,"        findAllOrderBy :: (HasEnvironment m) => OrderByParams -> m [model]"
  ,"        findAllWhereOrderBy :: (HasEnvironment m) => SelectString -> SelectParams -> OrderByParams -> m [model]"
  ,"        findOneWhere :: (HasEnvironment m) => SelectString -> SelectParams -> m model"
  ,"        findOneOrderBy :: (HasEnvironment m) => OrderByParams -> m model"
  ,"        findOneWhereOrderBy :: (HasEnvironment m) => SelectString -> SelectParams -> OrderByParams -> m model"
  ,""
  ,"class (DatabaseModel model) =>"
  ,"        HasFindByPrimaryKey model primaryKey | model -> primaryKey where"
  ,"    find   :: (HasEnvironment m) => primaryKey -> m model"
  ,"    update :: (HasEnvironment m) => model      -> m ()   "
  ,""
  ]

---------------------------------------------------------------------------
--  Generator templates                                                  --
---------------------------------------------------------------------------

generateIsModel :: TableName -> Columns -> TypeName -> [String]
generateIsModel t cs typeName =
    ["instance IsModel " ++ typeName ++ " where"
    ,"    insert m returnId = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res  <- liftIO $ HDBC.handleSqlError $ HDBC.run conn \" INSERT INTO " ++ t ++ " (" ++ (concat $ intersperse "," $ M.keys cs) ++") VALUES (" ++ (intercalate "," (take (M.size cs) (repeat "?"))) ++ ")\""
    ,"                  [" ++ (unwords $ intersperse "," $ map (\c -> "HDBC.toSql $ " ++ partiallyCapitalizeName c ++ " m") (M.keys cs) ) ++ "]"
    ,"        liftIO $ HDBC.handleSqlError $ HDBC.commit conn"
    ,"        if returnId"
    ,"          then do i <- liftIO $ HDBC.catchSql (HDBC.handleSqlError $ HDBC.quickQuery' conn \"SELECT lastval()\" []) (\\_ -> HDBC.commit conn >> (return $ [[HDBC.toSql (0 :: Int)]]) ) "
    ,"                  return $ HDBC.fromSql $ head $ head i"
    ,"          else return Nothing"
    ,"    findAll = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn \"SELECT " ++ cols cs ++ " FROM " ++ t ++ "\" []"
    ,"        return $ map (\\r -> " ++ generateConstructor cs typeName ++ ") res"
    ,"    findAllWhere ss sp = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " WHERE (\" ++ ss ++ \") \")  sp"
    ,"        return $ map (\\r -> " ++ generateConstructor cs typeName ++ ") res"
    ,"    findAllOrderBy op = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " ORDER BY ?\") [HDBC.toSql op]"
    ,"        return $ map (\\r -> " ++ generateConstructor cs typeName ++ ") res"
    ,"    findAllWhereOrderBy ss sp op = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " WHERE (\" ++ ss ++ \") ORDER BY ? \")  (sp ++ [HDBC.toSql op])"
    ,"        return $ map (\\r -> " ++ generateConstructor cs typeName ++ ") res"
    ,"    findOneWhere ss sp = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " WHERE (\" ++ ss ++ \") LIMIT 1\") sp"
    ,"        return $ (\\r -> " ++ generateConstructor cs typeName ++ ") (head res)"
    ,"    findOneOrderBy op = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " ORDER BY ? LIMIT 1\")  [HDBC.toSql op]"
    ,"        return $ (\\r -> " ++ generateConstructor cs typeName ++ ") (head res)"
    ,"    findOneWhereOrderBy ss sp op = do"
    ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
    ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " WHERE (\" ++ ss ++ \") ORDER BY ? LIMIT 1\")  (sp ++ [HDBC.toSql op])"
    ,"        return $ (\\r -> " ++ generateConstructor cs typeName ++ ") (head res)"
     ]

generateHasFindByPrimaryKey :: TableName -> Columns -> TypeName -> PrimaryKey -> [String]
generateHasFindByPrimaryKey t cs typeName pk =
  case (length  pk) of
    0 -> [""]
    _ -> ["instance HasFindByPrimaryKey " ++ typeName ++ " " ++ " (" ++ unwords (intersperse "," (map (\c -> getHaskellTypeString $ colType $ (\(c',_,_) -> c') $ fromJust $ M.lookup c cs) pk)) ++ ") " ++ " where"
         ,"    find pk@(" ++ (concat $ intersperse ", " $ map (\i -> "pk"++(show i)) [1..(length pk)]) ++ ") = do"
         ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
         ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t ++ " WHERE (" ++ (generatePrimaryKeyWhere pk) ++ ")\") [" ++ (unwords $ intersperse "," $ map (\(c,i) -> "HDBC.toSql pk" ++ (show i)) (zip pk [1..])) ++ "]"
         ,"        case res of"
         ,"          [] -> throwDyn $ HDBC.SqlError"
         ,"                           {HDBC.seState = \"\","
         ,"                            HDBC.seNativeError = (-1),"
         ,"                            HDBC.seErrorMsg = \"No record found when finding by Primary Key:" ++ t ++ " : \" ++ (show pk)"
         ,"                           }"
         ,"          r:[] -> return $ " ++ (generateConstructor cs typeName)
         ,"          _ -> throwDyn $ HDBC.SqlError"
         ,"                           {HDBC.seState = \"\","
         ,"                            HDBC.seNativeError = (-1),"
         ,"                            HDBC.seErrorMsg = \"Too many records found when finding by Primary Key:" ++ t ++ " : \" ++ (show pk)"
         ,"                           }"
         ,""
         ,"    update m = do"
         ,"        conn <- getEnvironment >>= (return . fromJust . getDatabase )"
         ,"        res <- liftIO $ HDBC.handleSqlError $ HDBC.run conn \"UPDATE " ++ t ++ " SET (" ++ (unwords $ intersperse "," $ M.keys cs) ++ ") = (" ++ (intercalate "," $ (take (M.size cs) (repeat "?"))) ++ ") WHERE (" ++ (generatePrimaryKeyWhere pk)  ++")\""
         ,"                  [" ++ (unwords $ intersperse "," $ map (\c -> "HDBC.toSql $ " ++ partiallyCapitalizeName c ++ " m") (M.keys cs) ) ++ ", " ++ (unwords $ intersperse "," $ map (\c -> "HDBC.toSql $ " ++ partiallyCapitalizeName c ++ " m") pk ) ++ "]"
         ,"        liftIO $ HDBC.handleSqlError $ HDBC.commit conn"
         ,"        return ()"
         ]

{-----------------------------------------------------------------------}
generatePrimaryKeyWhere pk = 
  unwords $
    intersperse "++ \" AND \" ++ \"" $
      map (\(c,i) -> c ++ " = ? ") (zip pk [1..])

generateConstructor cs typeName =
  typeName ++ " " ++ (unwords $
  map (\i -> "(HDBC.fromSql (r !! " ++ (show i) ++ "))") [0..((M.size cs) - 1)])

 
---------------------------------------------------------------------------
--  Utility functions                                                    --
---------------------------------------------------------------------------
cols :: Columns -> String
cols cs = unwords $  intersperse "," $ M.keys cs

columnToFieldLabel :: (String, (SqlColDesc, ForeignKeyReferences, HasDefault)) -> String
columnToFieldLabel cd@(name, (desc, _, _)) =
  "    " ++ partiallyCapitalizeName name  ++ " :: " ++ 
  maybeColumnLabel cd ++
  getHaskellTypeString (colType desc)

maybeColumnLabel :: (String, (SqlColDesc, ForeignKeyReferences, HasDefault)) -> String
maybeColumnLabel (_, (_, _, True)) = "Maybe "  -- Does the column have a default
maybeColumnLabel (_, (desc, _, _)) = if ((colNullable desc) == Just True) then "Maybe " else ""
maybeColumnLabel _                    = ""

getHaskellTypeString :: SqlTypeId -> String
getHaskellTypeString    SqlCharT = "String"
getHaskellTypeString    SqlVarCharT = "String"
getHaskellTypeString    SqlLongVarCharT = "String"
getHaskellTypeString    SqlWCharT = "String"
getHaskellTypeString    SqlWVarCharT = "String"
getHaskellTypeString    SqlWLongVarCharT = "String"
getHaskellTypeString    SqlDecimalT = "Rational"
getHaskellTypeString    SqlNumericT = "Rational"
getHaskellTypeString    SqlSmallIntT ="Int32"
getHaskellTypeString    SqlIntegerT = "Int32"
getHaskellTypeString    SqlRealT = "Rational"
getHaskellTypeString    SqlFloatT = "Float"
getHaskellTypeString    SqlDoubleT = "Double"
getHaskellTypeString    SqlTinyIntT = "Int32"
getHaskellTypeString    SqlBigIntT = "Int64"
getHaskellTypeString    SqlDateT = "ClockTime"
getHaskellTypeString    SqlTimeT = "ClockTime"
getHaskellTypeString    SqlTimestampT = "ClockTime"
getHaskellTypeString    SqlUTCDateTimeT = "ClockTime"
getHaskellTypeString    SqlUTCTimeT = "TimeDiff"
getHaskellTypeString    _ = error "Don't know how to translate this SqlTypeId to a SqlValue"


--type SelectParameters = String

--class TableType a where
--  find   :: (IConnection conn) => conn -> Int -> a
--  findBy :: (IConnection conn) => conn -> SelectParameters -> [a]

--  
-- Converts "column_name" to "ColumnName" (for types)
--
capitalizeName (colname':colname) =
     concat
      (map (\(s:ss) -> (Data.Char.toUpper s) : ss) $
        words $ (Data.Char.toUpper colname') : 
          map (\c -> if (c=='_') then ' ' else c) colname)


--  
-- Converts "column_name" to "columnName" (for functions)
--
partiallyCapitalizeName colname =
  (\(s:ss) -> (Data.Char.toLower s) : ss) $
   capitalizeName colname 
